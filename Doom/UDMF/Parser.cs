/*
 *  ChronosLib - A collection of useful things
 *  Copyright (C) 2018-2020 Chronos "phantombeta" Ouroboros
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
// Part of the code was generated by TinyPG.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using ChronosLib.Reflection;

namespace ChronosLib.Doom.UDMF.Internal {
    internal class ParserInfo {
        public interface IAssignmentInfo {
            #region ================== Instance properties

            Type PropType { get; }

            #endregion
        }

        public class AssignmentInfo<T> : IAssignmentInfo {
            #region ================== Instance fields

            public PropertyDelegates<T> Delegates;

            #endregion

            #region ================== Instance properties

            public Type PropType { get; set; }

            #endregion

            #region ================== Constructors

            public AssignmentInfo (PropertyInfo prop) {
                PropType = prop.PropertyType;
                Delegates = prop.CreateSetGetDelegates<T> (false, true);
            }

            #endregion

            #region ================== Instance methods

            public void Assign (object self, T val) {
                Delegates.Setter (self, val);
            }

            #endregion
        }

        public struct BlockInfo {
            #region ================== Instance fields

            public Type BlockType;
            public PropertyDelegates<IUDMFBlockList> Delegates;
            public Dictionary<string, IAssignmentInfo> Assignments;

            #endregion
        }

        #region ================== Instance fields

        public readonly Dictionary<string, BlockInfo> Blocks;
        public readonly Dictionary<string, IAssignmentInfo> GlobalAssignments;

        #endregion

        #region ================== Constructors

        public ParserInfo (Type dataType) {
            var udmfDataInfo = dataType.GetProperties ();

            Blocks = new Dictionary<string, BlockInfo> (udmfDataInfo.Length, StringComparer.InvariantCultureIgnoreCase);
            GlobalAssignments = new Dictionary<string, IAssignmentInfo> (udmfDataInfo.Length, StringComparer.InvariantCultureIgnoreCase);

            foreach (var prop in udmfDataInfo) {
                var dataAttr = prop.GetCustomAttribute<UDMFDataAttribute> ();
                var type = prop.PropertyType;

                if (dataAttr is null)
                    continue;

                if (UDMFParser_Internal.IsUDMFType (type)) {
                    GlobalAssignments.Add (
                        dataAttr.Identifier,
                        GetAssignmentInfo (prop)
                    );
                } else if (type.IsGenericType && type.GetGenericTypeDefinition () == typeof (UDMFBlockList<>)) {
                    var blockInfo = new BlockInfo ();
                    var blockType = type.GetGenericArguments () [0];

                    blockInfo.BlockType = blockType;
                    blockInfo.Delegates = prop.CreateSetGetDelegates<IUDMFBlockList> (true, true);
                    GetBlockInfo (blockType, ref blockInfo);

                    Blocks.Add (dataAttr.Identifier, blockInfo);
                }
            }
        }

        #endregion

        #region ================== Instance methods

        public void InitializeDataClass (UDMFParsedMapData data) {
            foreach (var block in Blocks.Values) {
                var propVal = block.Delegates.Getter (data);

                if (propVal is null) {
                    propVal = (IUDMFBlockList) Activator.CreateInstance (block.Delegates.Info.PropertyType);
                    block.Delegates.Setter (data, propVal);
                }
            }
        }

        private IAssignmentInfo GetAssignmentInfo (PropertyInfo prop) {
            if (prop.PropertyType == typeof (bool)) return new AssignmentInfo<bool> (prop);
            else if (prop.PropertyType == typeof (int)) return new AssignmentInfo<int> (prop);
            else if (prop.PropertyType == typeof (uint)) return new AssignmentInfo<uint> (prop);
            else if (prop.PropertyType == typeof (long)) return new AssignmentInfo<long> (prop);
            else if (prop.PropertyType == typeof (ulong)) return new AssignmentInfo<ulong> (prop);
            else if (prop.PropertyType == typeof (float)) return new AssignmentInfo<float> (prop);
            else if (prop.PropertyType == typeof (double)) return new AssignmentInfo<double> (prop);
            else if (prop.PropertyType == typeof (string)) return new AssignmentInfo<string> (prop);

            throw new ArgumentException ("", nameof (prop));
        }

        private void GetBlockInfo (Type type, ref BlockInfo blockInfo) {
            var udmfDataInfo = type.GetProperties ();

            blockInfo.Assignments = new Dictionary<string, IAssignmentInfo> (udmfDataInfo.Length, StringComparer.InvariantCultureIgnoreCase);

            foreach (var prop in udmfDataInfo) {
                var dataAttr = prop.GetCustomAttribute<UDMFDataAttribute> ();
                var propType = prop.PropertyType;

                if (dataAttr is null)
                    continue;

                blockInfo.Assignments.Add (
                    dataAttr.Identifier,
                    GetAssignmentInfo (prop)
                );
            }
        }

        #endregion
    }

    internal sealed class UDMFParser_Internal {
        #region ================== Instance fields

        private static Dictionary<Type, ParserInfo> parserInfoList;
        private UDMFScanner scanner;

        #endregion

        #region ================== Instance properties

        public List<UDMFParseError> Errors { get; set; }

        #endregion

        #region ================== Constructors

        public UDMFParser_Internal (UDMFScanner scanner) {
            parserInfoList = new Dictionary<Type, ParserInfo> ();
            this.scanner = scanner;
            Errors = new List<UDMFParseError> ();
        }

        #endregion

        #region ================== Instance methods

        #region Public & internal

        public UDMFParsedMapData Parse (string udmfSource, Type dataType) {
            scanner.Init (udmfSource);

            GetParserInfo (dataType);

            var data = (UDMFParsedMapData) Activator.CreateInstance (dataType);
            var info = GetParserInfo (dataType);
            info.InitializeDataClass (data);

            ParseGlobal_Expr_List (data, info);
            if (Errors.Count < 1)
                data.PostProcessing ();

            scanner.Reset ();

            return data;
        }

        internal static bool IsUDMFType (Type type) {
            switch (Type.GetTypeCode (type)) {
                case TypeCode.Int32:
                case TypeCode.Int64:
                case TypeCode.UInt32:
                case TypeCode.UInt64:
                case TypeCode.Single:
                case TypeCode.Double:
                case TypeCode.String:
                case TypeCode.Boolean:
                    return true;

                default:
                    return false;
            }
        }

        #endregion

        #region Private

        private ParserInfo GetParserInfo (Type dataType) {
            if (!parserInfoList.TryGetValue (dataType, out ParserInfo info)) {
                info = new ParserInfo (dataType);
                parserInfoList.Add (dataType, info);
            }

            return info;
        }

        private void ParseGlobal_Expr_List (UDMFParsedMapData dataClass, ParserInfo info) {
            if (dataClass.UnknownBlocks == null)
                dataClass.UnknownBlocks = new List<Tuple<string, UDMFUnknownBlock>> ();
            if (dataClass.UnknownGlobalAssignments == null)
                dataClass.UnknownGlobalAssignments = new Dictionary<string, string> (StringComparer.OrdinalIgnoreCase);

            UDMFToken tok = scanner.LookAhead ();
            while (tok.Type == UDMFTokenType.IDENTIFIER) {
                ParseGlobal_Expr (dataClass, info);

                tok = scanner.LookAhead ();
            }
        }

        private void ParseGlobal_Expr (UDMFParsedMapData dataClass, ParserInfo info) {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.IDENTIFIER) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.IDENTIFIER), 0x1001, tok));
                return;
            }

            var ident = tok;
            var identText = ident.Text.ToString ();

            tok = scanner.LookAhead ();
            switch (tok.Type) {
                case UDMFTokenType.BROPEN:
                    ParserInfo.BlockInfo block;
                    info.Blocks.TryGetValue (identText, out block);
                    ParseBlock (dataClass, identText, block);
                    break;
                case UDMFTokenType.EQSIGN:
                    if (info.GlobalAssignments.TryGetValue (identText, out var assignment))
                        ParseAssignment_Expr (dataClass, assignment);
                    else {
                        var val = ParseAssignment_Expr (dataClass, null);
                        dataClass.UnknownGlobalAssignments.Add (identText, val.Value.Text.ToString ());
                    }
                    break;
                default:
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found.", 0x0002, tok));
                    return;
            }

            return;
        }

        private void ParseBlock (UDMFParsedMapData dataClass, string ident, ParserInfo.BlockInfo? info) {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.BROPEN) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.BROPEN), 0x1001, tok));
                return;
            }

            IUDMFBlock block;
            if (info != null) {
                block = (IUDMFBlock) Activator.CreateInstance (info.Value.BlockType);
                ((IUDMFBlockList) info.Value.Delegates.Getter (dataClass)).AddBlock (block);
            } else {
                var newBlock = new UDMFUnknownBlock ();
                block = newBlock;
                dataClass.UnknownBlocks.Add (new Tuple<string, UDMFUnknownBlock> (ident, newBlock));
            }

            ParseExpr_List (block, info);

            tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.BRCLOSE) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.BRCLOSE), 0x1001, tok));
                return;
            }
        }

        private void ParseExpr_List (IUDMFBlock block, ParserInfo.BlockInfo? info) {
            if (block.UnknownAssignments == null)
                block.UnknownAssignments = new Dictionary<string, string> (StringComparer.OrdinalIgnoreCase);

            UDMFToken tok = scanner.LookAhead ();
            while (tok.Type == UDMFTokenType.IDENTIFIER) {
                tok = scanner.Scan ();
                if (tok.Type != UDMFTokenType.IDENTIFIER) {
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.IDENTIFIER), 0x1001, tok));
                    return;
                }

                if (info != null && info.Value.Assignments.TryGetValue (tok.Text.ToString (), out var assignment))
                    ParseAssignment_Expr (block, assignment);
                else {
                    var val = ParseAssignment_Expr (block, null);
                    block.UnknownAssignments.Add (tok.Text.ToString (), val.Value.Text.ToString ());
                }

                tok = scanner.LookAhead ();
            }
        }

        private static void SetAssignmentInfo<T> (ParserInfo.IAssignmentInfo info, object self, T val) {
            ((ParserInfo.AssignmentInfo<T>) info).Assign (self, val);
        }

        private UDMFToken? ParseAssignment_Expr (object block, ParserInfo.IAssignmentInfo data) {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.EQSIGN) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.EQSIGN), 0x1001, tok));
                return null;
            }

            var valTok = scanner.Scan ();
            var valTokText = valTok.Text;
            if (data != null) {
                switch (Type.GetTypeCode (data.PropType)) {
                    case TypeCode.Boolean: {
                        bool val;

                        if (valTokText.Equals ("true".AsSpan (), StringComparison.InvariantCultureIgnoreCase))
                            val = true;
                        else if (valTokText.Equals ("false".AsSpan (), StringComparison.InvariantCultureIgnoreCase))
                            val = false;
                        else {
                            Errors.Add (new UDMFParseError ("Expected bool, got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }

                        SetAssignmentInfo (data, block, val);
                    }
                    break;

                    case TypeCode.Int32: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        int.TryParse (valTokText.ToString (), NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo (data, block, val);
                    }
                    break;
                    case TypeCode.Int64: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        long.TryParse (valTokText.ToString (), NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo (data, block, val);
                    }
                    break;
                    case TypeCode.UInt32: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        uint.TryParse (valTokText.ToString (), NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo (data, block, val);
                    }
                    break;
                    case TypeCode.UInt64: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        ulong.TryParse (valTokText.ToString (), NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo (data, block, val);
                    }
                    break;

                    case TypeCode.Single: {
                        if (valTok.Type != UDMFTokenType.FLOAT && valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.FLOAT) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        float.TryParse (valTokText.ToString (), NumberStyles.Integer | NumberStyles.Float, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo (data, block, val);
                    }
                    break;
                    case TypeCode.Double: {
                        if (valTok.Type != UDMFTokenType.FLOAT && valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.FLOAT) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        double.TryParse (valTokText.ToString (), NumberStyles.Integer | NumberStyles.Float, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo (data, block, val);
                    }
                    break;

                    case TypeCode.String:
                        if (valTok.Type != UDMFTokenType.QUOTED_STRING) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.QUOTED_STRING) + ", got " + UDMFToken.TokenTypeToString (valTok.Type) + ".", 0x1001, valTok));
                            break;
                        }
                        SetAssignmentInfo (data, block, valTokText.Slice (1, valTokText.Length - 2).ToString ().Replace ("\\\"", "\"").Replace (@"\\", @"\"));
                        break;

                    default:
                        throw new NotImplementedException ();
                }
            }

            tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.SEMICOLON) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.ToString ().Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.SEMICOLON), 0x1001, tok));
                return null;
            }

            return valTok;
        }

        #endregion

        #endregion
    }
}
