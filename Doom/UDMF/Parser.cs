/*
 *  ChronosLib - A collection of useful things
 *  Copyright (C) 2018-2019 Chronos "phantombeta" Ouroboros
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
// Part of the code was generated by TinyPG.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using ChronosLib.Reflection;

namespace ChronosLib.Doom.UDMF.Internal {
    internal sealed class UDMFParser_Internal {
        private static Dictionary<Type, ParserInfo> parserInfoList = new Dictionary<Type, ParserInfo> ();
        private UDMFScanner scanner;
        public List<UDMFParseError> Errors { get; set; }

        public UDMFParser_Internal (UDMFScanner scanner) {
            this.scanner = scanner;
            this.Errors = new List<UDMFParseError> ();
        }

        private static bool IsUDMFType (Type type) {
            switch (Type.GetTypeCode (type)) {
                case TypeCode.Int32:
                case TypeCode.Int64:
                case TypeCode.UInt32:
                case TypeCode.UInt64:
                case TypeCode.Single:
                case TypeCode.Double:
                case TypeCode.String:
                case TypeCode.Boolean:
                    return true;

                default:
                    return false;
            }
        }

        private class ParserInfo {
            public interface IAssignmentInfo {
                Type propType { get; }
            }

            public class AssignmentInfo<T> : IAssignmentInfo {
                public Type propType { get; set; }
                public PropertyDelegates<T> delegates;

                public AssignmentInfo (PropertyInfo prop) {
                    propType = prop.PropertyType;
                    delegates = prop.CreateSetGetDelegates<T> (false, true);
                }

                public void Assign (object self, T val) {
                    delegates.Setter (self, val);
                }
            }

            public struct BlockInfo {
                public Type blockType;
                public PropertyDelegates<IUDMFBlockList> delegates;
                public Dictionary<string, IAssignmentInfo> assignments;
            }

            public readonly Dictionary<string, BlockInfo> blocks;
            public readonly Dictionary<string, IAssignmentInfo> globalAssignments;

            public ParserInfo (Type dataType) {
                var udmfDataInfo = dataType.GetProperties ();

                blocks = new Dictionary<string, BlockInfo> (udmfDataInfo.Length, StringComparer.InvariantCultureIgnoreCase);
                globalAssignments = new Dictionary<string, IAssignmentInfo> (udmfDataInfo.Length, StringComparer.InvariantCultureIgnoreCase);

                foreach (var prop in udmfDataInfo) {
                    var dataAttr = prop.GetCustomAttribute<UDMFDataAttribute> ();
                    var type = prop.PropertyType;

                    if (dataAttr is null)
                        continue;

                    if (IsUDMFType (type)) {
                        globalAssignments.Add (
                            dataAttr.Identifier,
                            GetAssignmentInfo (prop)
                        );
                    } else if (type.IsGenericType && type.GetGenericTypeDefinition () == typeof (UDMFBlockList<>)) {
                        var blockInfo = new BlockInfo ();
                        var blockType = type.GetGenericArguments () [0];

                        blockInfo.blockType = blockType;
                        blockInfo.delegates = prop.CreateSetGetDelegates<IUDMFBlockList> (true, true);
                        GetBlockInfo (blockType, ref blockInfo);

                        blocks.Add (dataAttr.Identifier, blockInfo);
                    }
                }
            }

            private IAssignmentInfo GetAssignmentInfo (PropertyInfo prop) {
                if      (prop.PropertyType == typeof (bool  )) return new AssignmentInfo<bool  > (prop);
                else if (prop.PropertyType == typeof (int   )) return new AssignmentInfo<int   > (prop);
                else if (prop.PropertyType == typeof (uint  )) return new AssignmentInfo<uint  > (prop);
                else if (prop.PropertyType == typeof (long  )) return new AssignmentInfo<long  > (prop);
                else if (prop.PropertyType == typeof (ulong )) return new AssignmentInfo<ulong > (prop);
                else if (prop.PropertyType == typeof (float )) return new AssignmentInfo<float > (prop);
                else if (prop.PropertyType == typeof (double)) return new AssignmentInfo<double> (prop);
                else if (prop.PropertyType == typeof (string)) return new AssignmentInfo<string> (prop);

                throw new ArgumentException ("", nameof (prop));
            }

            private void GetBlockInfo (Type type, ref BlockInfo blockInfo) {
                var udmfDataInfo = type.GetProperties ();

                blockInfo.assignments = new Dictionary<string, IAssignmentInfo> (udmfDataInfo.Length, StringComparer.InvariantCultureIgnoreCase);

                foreach (var prop in udmfDataInfo) {
                    var dataAttr = prop.GetCustomAttribute<UDMFDataAttribute> ();
                    var propType = prop.PropertyType;

                    if (dataAttr is null)
                        continue;

                    blockInfo.assignments.Add (
                        dataAttr.Identifier,
                        GetAssignmentInfo (prop)
                    );
                }
            }

            public void InitializeDataClass (UDMFParsedMapData data) {
                foreach (var block in blocks.Values) {
                    var propVal = block.delegates.Getter (data);

                    if (propVal is null) {
                        propVal = (IUDMFBlockList) Activator.CreateInstance (block.delegates.Info.PropertyType);
                        block.delegates.Setter (data, propVal);
                    }
                }
            }
        }

        private ParserInfo GetParserInfo (Type dataType) {
            if (!parserInfoList.TryGetValue (dataType, out ParserInfo info)) {
                info = new ParserInfo (dataType);
                parserInfoList.Add (dataType, info);
            }

            return info;
        }

        public UDMFParsedMapData Parse (TextReader reader, Type dataType) {
            scanner.Init (reader);

            GetParserInfo (dataType);

            var data = (UDMFParsedMapData) Activator.CreateInstance (dataType);
            var info = GetParserInfo (dataType);
            info.InitializeDataClass (data);

            ParseGlobal_Expr_List (data, info);
            if (Errors.Count < 1)
                data.PostProcessing ();

            scanner.Reset ();

            return data;
        }

        private void ParseGlobal_Expr_List (UDMFParsedMapData dataClass, ParserInfo info) {
            if (dataClass.UnknownBlocks == null)
                dataClass.UnknownBlocks = new List<Tuple<string, UDMFUnknownBlock>> ();
            if (dataClass.UnknownGlobalAssignments == null)
                dataClass.UnknownGlobalAssignments = new Dictionary<string, string> (StringComparer.OrdinalIgnoreCase);

            UDMFToken tok = scanner.LookAhead ();
            while (tok.Type == UDMFTokenType.IDENTIFIER) {
                ParseGlobal_Expr (dataClass, info);

                tok = scanner.LookAhead ();
            }
        }

        private void ParseGlobal_Expr (UDMFParsedMapData dataClass, ParserInfo info) {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.IDENTIFIER) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.IDENTIFIER), 0x1001, tok));
                return;
            }

            var ident = tok;

            tok = scanner.LookAhead ();
            switch (tok.Type) {
                case UDMFTokenType.BROPEN:
                    ParserInfo.BlockInfo block;
                    info.blocks.TryGetValue (ident.Text, out block);
                    ParseBlock (dataClass, ident.Text, block);
                    break;
                case UDMFTokenType.EQSIGN:
                    if (info.globalAssignments.TryGetValue (ident.Text, out var assignment))
                        ParseAssignment_Expr (dataClass, assignment);
                    else {
                        var val = ParseAssignment_Expr (dataClass, null);
                        dataClass.UnknownGlobalAssignments.Add (ident.Text, val.Value.Text);
                    }
                    break;
                default:
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found.", 0x0002, tok));
                    return;
            }

            return;
        }

        private void ParseBlock (UDMFParsedMapData dataClass, string ident, ParserInfo.BlockInfo? info) {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.BROPEN) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.BROPEN), 0x1001, tok));
                return;
            }

            IUDMFBlock block;
            if (info != null) {
                block = (IUDMFBlock) Activator.CreateInstance (info.Value.blockType);
                ((IUDMFBlockList) info.Value.delegates.Getter (dataClass)).AddBlock (block);
            } else {
                var newBlock = new UDMFUnknownBlock ();
                block = newBlock;
                dataClass.UnknownBlocks.Add (new Tuple<string, UDMFUnknownBlock> (ident, newBlock));
            }

            ParseExpr_List (block, info);

            tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.BRCLOSE) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.BRCLOSE), 0x1001, tok));
                return;
            }
        }

        private void ParseExpr_List (IUDMFBlock block, ParserInfo.BlockInfo? info) {
            if (block.UnknownAssignments == null)
                block.UnknownAssignments = new Dictionary<string, string> (StringComparer.OrdinalIgnoreCase);

            UDMFToken tok = scanner.LookAhead ();
            while (tok.Type == UDMFTokenType.IDENTIFIER) {
                tok = scanner.Scan ();
                if (tok.Type != UDMFTokenType.IDENTIFIER) {
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.IDENTIFIER), 0x1001, tok));
                    return;
                }

                if (info != null && info.Value.assignments.TryGetValue (tok.Text, out var assignment))
                    ParseAssignment_Expr (block, assignment);
                else {
                    var val = ParseAssignment_Expr (block, null);
                    block.UnknownAssignments.Add (tok.Text, val.Value.Text);
                }

                tok = scanner.LookAhead ();
            }
        }

        private static void SetAssignmentInfo<T> (ParserInfo.IAssignmentInfo info, object self, T val) {
            ((ParserInfo.AssignmentInfo<T>) info).Assign (self, val);
        }

        private UDMFToken? ParseAssignment_Expr (object block, ParserInfo.IAssignmentInfo data) {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.EQSIGN) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.EQSIGN), 0x1001, tok));
                return null;
            }

            var valTok = scanner.Scan ();
            if (data != null) {
                switch (Type.GetTypeCode (data.propType)) {
                    case TypeCode.Boolean: {
                        bool val;

                        if (valTok.Text.Equals ("true", StringComparison.InvariantCultureIgnoreCase))
                            val = true;
                        else if (valTok.Text.Equals ("false", StringComparison.InvariantCultureIgnoreCase))
                            val = false;
                        else {
                            Errors.Add (new UDMFParseError ("Expected bool, got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }

                        SetAssignmentInfo<bool> (data, block, val);
                    }
                    break;

                    case TypeCode.Int32: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        int.TryParse (valTok.Text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo<int> (data, block, val);
                    }
                    break;
                    case TypeCode.Int64: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        long.TryParse (valTok.Text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo<long> (data, block, val);
                    }
                    break;
                    case TypeCode.UInt32: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        uint.TryParse (valTok.Text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo<uint> (data, block, val);
                    }
                    break;
                    case TypeCode.UInt64: {
                        if (valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.INTEGER) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        ulong.TryParse (valTok.Text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo<ulong> (data, block, val);
                    }
                    break;

                    case TypeCode.Single: {
                        if (valTok.Type != UDMFTokenType.FLOAT && valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.FLOAT) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        float.TryParse (valTok.Text, NumberStyles.Integer | NumberStyles.Float, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo<float> (data, block, val);
                    }
                    break;
                    case TypeCode.Double: {
                        if (valTok.Type != UDMFTokenType.FLOAT && valTok.Type != UDMFTokenType.INTEGER) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.FLOAT) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        double.TryParse (valTok.Text, NumberStyles.Integer | NumberStyles.Float, CultureInfo.InvariantCulture, out var val);
                        SetAssignmentInfo<double> (data, block, val);
                    }
                    break;

                    case TypeCode.String:
                        if (valTok.Type != UDMFTokenType.QUOTED_STRING) {
                            Errors.Add (new UDMFParseError ("Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.QUOTED_STRING) + ", got " + UDMFToken.TokenTypeToString (tok.Type) + ".", 0x1001, tok));
                            break;
                        }
                        SetAssignmentInfo<string> (data, block, valTok.Text);
                        break;

                    default:
                        throw new NotImplementedException ();
                }
            }

            tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.SEMICOLON) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFToken.TokenTypeToString (UDMFTokenType.SEMICOLON), 0x1001, tok));
                return null;
            }

            return valTok;
        }
    }
}
