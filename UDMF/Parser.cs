/*
 *  GZDoomLib - A library for using GZDoom's file formats in C#
 *  Copyright (C) 2018-2019 Chronos "phantombeta" Ouroboros
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
// Part of the code was generated by TinyPG.

using System;
using System.Collections.Generic;
using System.IO;

namespace GZDoomLib.UDMF.Internal {
    #region Parser

    public partial class UDMFParser_Internal {
        private UDMFScanner scanner;
        public UDMFParseErrors Errors { get; set; }

        public UDMFParser_Internal (UDMFScanner scanner) {
            this.scanner = scanner;
            this.Errors = new UDMFParseErrors ();
        }

        public List<Tuple<UDMFToken, object>> Parse (string input) {
            using (var reader = new StringReader (input))
                return Parse (reader);
        }

        public List<Tuple<UDMFToken, object>> Parse (Stream input) {
            using (var reader = new StreamReader (input))
                return Parse (reader);
        }

        public List<Tuple<UDMFToken, object>> Parse (TextReader reader) {
            scanner.Init (reader);

            var ret = ParseGlobal_Expr_List ();

            scanner.Reset ();

            return ret;
        }

        private List<Tuple<UDMFToken, object>> ParseGlobal_Expr_List () {
            var expressions = new List<Tuple<UDMFToken, object>> ();

            UDMFToken tok = scanner.LookAhead ();
            while (tok.Type == UDMFTokenType.IDENTIFIER) {
                var data = ParseGlobal_Expr ();

                expressions.Add (new Tuple<UDMFToken, object> (tok, data));

                tok = scanner.LookAhead ();
            }

            return expressions;
        }

        private Tuple<UDMFToken, object> ParseGlobal_Expr () {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.IDENTIFIER) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.IDENTIFIER.ToString (), 0x1001, tok));
                return null;
            }

            var ident = tok;
            object data;

            tok = scanner.LookAhead ();
            switch (tok.Type) {
                case UDMFTokenType.BROPEN:
                    data = ParseBlock ();
                    break;
                case UDMFTokenType.EQSIGN:
                    data = ParseAssignment_Expr ();
                    break;
                default:
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found.", 0x0002, tok));
                    return null;
            }

            return new Tuple<UDMFToken, object> (ident, data);
        }

        private List<Tuple<UDMFToken, UDMFToken>> ParseBlock () {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.BROPEN) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.BROPEN.ToString (), 0x1001, tok));
                return null;
            }

            var value = ParseExpr_List ();

            tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.BRCLOSE) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.BRCLOSE.ToString (), 0x1001, tok));
                return null;
            }

            return value;
        }

        private List<Tuple<UDMFToken, UDMFToken>> ParseExpr_List () {
            var expressions = new List<Tuple<UDMFToken, UDMFToken>> ();

            UDMFToken tok = scanner.LookAhead ();
            while (tok.Type == UDMFTokenType.IDENTIFIER) {
                tok = scanner.Scan ();
                if (tok.Type != UDMFTokenType.IDENTIFIER) {
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.IDENTIFIER.ToString (), 0x1001, tok));
                    return null;
                }

                var value = ParseAssignment_Expr ();
                expressions.Add (new Tuple<UDMFToken, UDMFToken> (tok, value));

                tok = scanner.LookAhead ();
            }

            return expressions;
        }

        private UDMFToken ParseAssignment_Expr () {
            UDMFToken tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.EQSIGN) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.EQSIGN.ToString (), 0x1001, tok));
                return null;
            }

            var value = ParseValue ();

            tok = scanner.Scan ();
            if (tok.Type != UDMFTokenType.SEMICOLON) {
                Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.SEMICOLON.ToString (), 0x1001, tok));
                return null;
            }

            return value;
        }

        private UDMFToken ParseValue () {
            UDMFToken tok = scanner.LookAhead ();

            switch (tok.Type) {
                case UDMFTokenType.INTEGER:
                    tok = scanner.Scan ();
                    if (tok.Type != UDMFTokenType.INTEGER) {
                        Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.INTEGER.ToString (), 0x1001, tok));
                        return null;
                    }
                    break;
                case UDMFTokenType.FLOAT:
                    tok = scanner.Scan ();
                    if (tok.Type != UDMFTokenType.FLOAT) {
                        Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.FLOAT.ToString (), 0x1001, tok));
                        return null;
                    }
                    break;
                case UDMFTokenType.QUOTED_STRING:
                    tok = scanner.Scan ();
                    if (tok.Type != UDMFTokenType.QUOTED_STRING) {
                        Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.QUOTED_STRING.ToString (), 0x1001, tok));
                        return null;
                    }
                    break;
                case UDMFTokenType.IDENTIFIER:
                    tok = scanner.Scan ();
                    if (tok.Type != UDMFTokenType.IDENTIFIER) {
                        Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.IDENTIFIER.ToString (), 0x1001, tok));
                        return null;
                    }
                    break;
                /*case UDMFTokenType.KEYWORD:
                    tok = scanner.Scan ();
                    n = node.CreateNode (tok);
                    node.Token.UpdateRange (tok);
                    node.AddNode (n);
                    if (tok.Type != UDMFTokenType.KEYWORD) {
                        Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found. Expected " + UDMFTokenType.KEYWORD.ToString (), 0x1001, node));
                        return;
                    }
                    break;*/
                default:
                    Errors.Add (new UDMFParseError ("Unexpected token '" + tok.Text.Replace ("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            return tok;
        }
    }

    #endregion Parser
}
