/*
 *  GZDoomLib - A library for using GZDoom's file formats in C#
 *  Copyright (C) 2018-2019 Chronos "phantombeta" Ouroboros
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
// Part of the code was generated by TinyPG.

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace GZDoomLib.UDMF.Internal {
    #region ParseTree

    [Serializable]
    public class UDMFParseErrors : List<UDMFParseError> {
    }

    [Serializable]
    public class UDMFParseError {
        public int Code { get; }
        public int Line { get; }
        public int Column { get; }
        public int Position { get; }
        public int Length { get; }
        public string Message { get; }

        // just for the sake of serialization
        public UDMFParseError () {
        }

        public UDMFParseError (string message, int code, UDMFToken tok) : this (message, code, tok.Line, tok.Column, tok.StartPos, tok.Length) {
        }

        public UDMFParseError (string message, int code, int line, int col, int pos, int length) {
            Message = message;
            Code = code;
            Line = line;
            Column = col;
            Position = pos;
            Length = length;
        }
    }

    /*// Root level of the node tree
    [Serializable]
    public class UDMFParseTree : UDMFParseNode {
        public UDMFParseErrors Errors;

        public List<UDMFToken> Skipped;

        public UDMFParseTree () : base (new UDMFToken (), "ParseTree") {
            Token.Type = UDMFTokenType.Start;
            Token.Text = "Root";
            Errors = new UDMFParseErrors ();
        }

        public string PrintTree () {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode (sb, this, indent);
            return sb.ToString ();
        }

        private void PrintNode (StringBuilder sb, UDMFParseNode node, int indent) {
            string space = "".PadLeft(indent, ' ');

            sb.Append (space);
            sb.AppendLine (node.Text);

            var curNode = node.Children;
            while (node != null) {
                PrintNode (sb, curNode, indent + 2);
                curNode = node.NextSibling;
            }
        }

        /// <summary>
        /// This is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">Additional optional input parameters</param>
        /// <returns>The output of the evaluation function</returns>
        public object Eval (params object [] paramlist) {
            return children.Eval (this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude (typeof (UDMFParseTree))]
    public class UDMFParseNode {
        protected string text;
        protected UDMFParseNode children;
        protected UDMFParseNode lastChild;
        protected UDMFParseNode nextSibling;

        public UDMFParseNode Children { get => children; }
        public UDMFParseNode NextSibling { get => nextSibling; }

        [XmlIgnore] // Avoid circular references when serializing
        public UDMFParseNode Parent;
        public UDMFToken Token; // The token/rule

        [XmlIgnore] // Skip redundant text (is part of Token)
        public string Text => text; // Text to display in parse tree

        public virtual UDMFParseNode CreateNode (UDMFToken token, string text = "") {
            var node = new UDMFParseNode (token, text);
            node.Parent = this;
            return node;
        }

        public void AddChildNode (UDMFParseNode node) {
            if (lastChild is null) {
                children = node;
                lastChild = node;
                return;
            }
            lastChild.nextSibling = node;
            lastChild = node;
        }

        protected UDMFParseNode (UDMFToken token, string text) {
            Token = token;
            this.text = text;
        }

        /// <summary>
        /// This implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">The parsetree itself</param>
        /// <param name="paramlist">Optional input parameters</param>
        /// <returns>A partial result of the evaluation</returns>
        internal object Eval (UDMFParseTree tree, params object [] paramlist) {
            object value;

            switch (Token.Type) {
                case UDMFTokenType.Start:
                    value = EvalStart (tree, paramlist);
                    break;
                case UDMFTokenType.Global_Expr_List:
                    value = EvalGlobal_Expr_List (tree, paramlist);
                    break;
                case UDMFTokenType.Global_Expr:
                    value = EvalGlobal_Expr (tree, paramlist);
                    break;
                case UDMFTokenType.Block:
                    value = EvalBlock (tree, paramlist);
                    break;
                case UDMFTokenType.Expr_List:
                    value = EvalExpr_List (tree, paramlist);
                    break;
                case UDMFTokenType.Assignment_Expr:
                    value = EvalAssignment_Expr (tree, paramlist);
                    break;
                case UDMFTokenType.Value:
                    value = EvalValue (tree, paramlist);
                    break;

                default:
                    value = Token.Text;
                    break;
            }

            return value;
        }

        protected virtual object EvalStart (UDMFParseTree tree, params object [] paramlist) {
            var node = children;
            while (node != null) {
                if (node.Token.Type == UDMFTokenType.Global_Expr_List)
                    return node.Eval (tree);

                node = node.nextSibling;
            }

            return null;
        }

        protected virtual object EvalGlobal_Expr_List (UDMFParseTree tree, params object [] paramlist) {
            var data = new UDMFParsedMapData ();

            var node = children;
            while (node != null) {
                if (node.Token.Type != UDMFTokenType.Global_Expr) {
                    node = node.nextSibling;
                    continue;
                }

                var expr = (node.Eval (tree) as UDMFDataPair);

                if (expr.Data is List<UDMFDataPair>)
                    EvalGlobal_Expr_List_HandleBlock (tree, node, expr, data);
                else
                    EvalGlobal_Expr_List_HandleAssignment (tree, node, expr, data);

                node = node.nextSibling;
            }

            return data;
        }

        protected virtual void EvalGlobal_Expr_List_HandleAssignment (UDMFParseTree tree, UDMFParseNode node, UDMFDataPair expr, UDMFParsedMapData data) {
            switch (expr.Name.ToLowerInvariant ()) {
                case "namespace":
                    if (expr.Data is string ns)
                        data.Namespace = ns;
                    else
                        tree.Errors.Add (new UDMFParseError ("Namespace must be a string, got " + expr.Data.GetType ().Name, 0, node));
                    break;

                default:
                    data.GlobalAssignments.Add (expr);
                    break;
            }
        }

        protected virtual void EvalGlobal_Expr_List_HandleBlock (UDMFParseTree tree, UDMFParseNode node, UDMFDataPair expr, UDMFParsedMapData data) {
            switch (expr.Name.ToLowerInvariant ()) {
                case "vertex":
                    data.Vertices.Add ((List<UDMFDataPair>) expr.Data);
                    break;
                case "linedef":
                    data.Linedefs.Add ((List<UDMFDataPair>) expr.Data);
                    break;
                case "sidedef":
                    data.Sidedefs.Add ((List<UDMFDataPair>) expr.Data);
                    break;
                case "sector":
                    data.Sectors.Add ((List<UDMFDataPair>) expr.Data);
                    break;
                case "thing":
                    data.Things.Add ((List<UDMFDataPair>) expr.Data);
                    break;

                default:
                    data.CustomBlocks.Add (new Tuple<string, List<UDMFDataPair>> (expr.Name, (List<UDMFDataPair>) expr.Data));
                    break;
            }
        }

        protected virtual object EvalGlobal_Expr (UDMFParseTree tree, params object [] paramlist) {
            var node = children;

            string identifier = null;
            object value = null;
            while (node != null) {
                if (identifier is null && node.Token.Type == UDMFTokenType.IDENTIFIER)
                    identifier = (string) node.Eval (tree);
                else if (value is null && (node.Token.Type == UDMFTokenType.Block || node.Token.Type == UDMFTokenType.Assignment_Expr))
                    value = node.Eval (tree);

                if (identifier != null && value != null)
                    break;

                node = node.nextSibling;
            }

            return new UDMFDataPair (identifier, value);
        }

        protected virtual object EvalBlock (UDMFParseTree tree, params object [] paramlist) {
            var nodesCount = 0;
            var node = children;
            while (node != null) {
                nodesCount++;
                node = node.nextSibling;
            }

            var exprList = new List<UDMFDataPair> (nodesCount);
            node = children;
            while (node != null) {
                exprList.Add ((UDMFDataPair) (node.Eval (tree)));
                node = node.nextSibling;
            }

            return exprList;
        }

        protected virtual object EvalExpr_List (UDMFParseTree tree, params object [] paramlist) {
            var node = children;

            string identifier = null;
            object value = null;
            while (node != null) {
                if (identifier is null && node.Token.Type == UDMFTokenType.IDENTIFIER)
                    identifier = (string) node.Eval (tree);
                else if (value is null && node.Token.Type == UDMFTokenType.Assignment_Expr)
                    value = node.Eval (tree);

                if (identifier != null && value != null)
                    break;

                node = node.nextSibling;
            }

            return new UDMFDataPair (identifier, value);
        }

        protected virtual object EvalAssignment_Expr (UDMFParseTree tree, params object [] paramlist) {
            var node = children;
            while (node != null) {
                if (node.Token.Type == UDMFTokenType.Value)
                    return node.Eval (tree);

                node = node.nextSibling;
            }

            return null;
        }

        protected virtual object EvalValue (UDMFParseTree tree, params object [] paramlist) {
            var node = children;
            while (node != null) {
                switch (node.Token.Type) {
                    case UDMFTokenType.INTEGER:
                        return int.Parse ((string) node.Eval (tree), System.Globalization.CultureInfo.InvariantCulture);
                    case UDMFTokenType.FLOAT:
                        return double.Parse ((string) node.Eval (tree), System.Globalization.CultureInfo.InvariantCulture);
                    case UDMFTokenType.QUOTED_STRING:
                        return (string) node.Eval (tree);
                    case UDMFTokenType.IDENTIFIER:
                        return (string) node.Eval (tree);
                }

                node = node.nextSibling;
            }
            
            //else if (GetValue (tree, UDMFTokenType.KEYWORD, 0) != null)
            //    return (string) GetValue (tree, UDMFTokenType.KEYWORD, 0);

            return null;
        }
    }*/

    #endregion ParseTree
}
